#include "MyFlavKtPlugin.hh"
#include "fastjet/ClusterSequence.hh"
#include "ktflavf77.h"
#include <sstream>
#include <utility>

using namespace std;

FASTJET_BEGIN_NAMESPACE      // defined in fastjet/internal/base.hh

const FlavInfo MyFlavKtPlugin::_no_flav;

//----------------------------------------------------------------------
std::string MyFlavKtPlugin::description() const {
  ostringstream ostr;
  ostr << "Flavour-enabled Kt family Algorithm, imode = ";
  ostr << _imode;
  ostr << ", R = " << _R;
  return ostr.str();
}


//----------------------------------------------------------------------
void MyFlavKtPlugin::run_clustering(ClusterSequence & cs) const {

  int    np = cs.jets().size();
  double pp[4*np], p[4];
  int    nflav = 6;
  int    flav[nflav*np], beamflav[nflav*2];
  
  // lookup table: lookup[i] tells you what position i in the
  // nodelist corresponds to in our list of jets
  vector<int> lookup(2*np+1);

  vector<int> beam_particles;
  vector<int> spectators;
  bool found_flavour = false;
  
  vector<double> pt(np);
  
  for (int ii=0;ii++;ii<np){
    pt[ii]=cs.jets()[ii].pt();
      for (int jj=ii+1;jj++;jj<np){
	cs.jets()[ii].kt_distance(cs.jets()[jj]);
      }
  }
  
  int j = 0; // index in fortran array
  for (int i = 0; i < np; i++) {
    const PseudoJet & particle = cs.jets()[i];
    const FlavInfo & flavour = flavour_of(particle);
    found_flavour |= (!flavour.is_flavourless());
    if (flavour.is_beam()) {
      beam_particles.push_back(i); 
      continue;
    }

    pp[0+4*j] = particle.px();
    pp[1+4*j] = particle.py();
    pp[2+4*j] = particle.pz();
    pp[3+4*j] = particle.E() ;
    // set the fortran flav array based on the C++ flavour array
    for (int iflav = 0; iflav < nflav; iflav++) flav[iflav+nflav*j] = flavour[iflav+1];
    lookup[np+1+j] = i;
    j++;
  }
  // the lookup table started from np; but actually needs to start
  // from the "fortran" np, i.e. the number of particles passed to the
  // fortran code; so now shift things appropriately
  for (int i = 0; i < j; i++) {
    lookup[j+1+i] = lookup[np+1+i];
  }
  np = j; // np is now the number of "fortran" particles
  
  // set up the extras structure
  MyFlavKtPlugin::Extras * extras = new MyFlavKtPlugin::Extras(cs);
  // beam indices will run in parallel with the history (ideally, they would
  // be stored in the history) [NB: do not use "np" here, because it may have changed]
  extras->_beam_indices.reserve(2*cs.history().size());
  extras->_beam_indices.resize(cs.history().size(),0); 

  // now get the beam flavour
  BeamFlavPair beam_flavour;
  if (beam_particles.size() == 0) {
    //-----------------------------------
    // no beams: invent flavourless beams
    beam_flavour.backward = _no_flav;
    beam_flavour.forward  = _no_flav;
    if (spectators.size() != 0) throw Error("There were spectators but no beams; this is not allowed");
  } else if (beam_particles.size() == 2){
    //-----------------------------------
    // we have two beams
    // first entry should have smaller rapidity (i.e. negative pz)
    int b1 = beam_particles[0];
    int b2 = beam_particles[1];
    if (cs.jets()[b1].rap() > cs.jets()[b2].rap()) std::swap(b1,b2);
    beam_flavour.backward = flavour_of(cs.jets()[b1]);
    beam_flavour.forward  = flavour_of(cs.jets()[b2]);
    // cluster the beam particles with the "beam", simply to get rid of them.
    // b2 goes first to help correspondence with tiled-strategies ordering of plain kt.
    cs.plugin_record_iB_recombination(b2, 0.0); // dij = 0
    extras->_beam_indices.push_back(+1);
    cs.plugin_record_iB_recombination(b1, 0.0); // dij = 0
    extras->_beam_indices.push_back(-1);
  } else {
    //-----------------------------------
    ostringstream str;
    str << "Found " << beam_particles.size() << " beams; only legitimate values are 0 or 2";
    throw Error(str.str());
  }

  // transfer beam flavour info to f77 array
  for (int iflav = 0; iflav < nflav; iflav++) {
    beamflav[iflav         ] = beam_flavour.backward[iflav+1];
    beamflav[iflav + nflav ] = beam_flavour.forward [iflav+1];
  }
  
  // the f90 code via its f77 interface
  ktf77MakeNodeListFlav(_imode, _R, np, pp, nflav, flav, beamflav);

  beam_flavour.label_as_beam(); // always do this to make sure we have correct labelling
  extras->_beam_flavs.push_back(beam_flavour);


  // decant the information from the f90 node list
  int    parent1, parent2;
  double dij;

  int beam_index;
  for (int i = np; i > 0; i--) {
    ktf77ReadNodeList(i, p, parent1, parent2, dij);
    
    if (parent1 > 0) {
      PseudoJet newjet(p);
      // track the jet flavour
      FlavInfo newflav =   flavour_of(cs.jets()[lookup[parent1]])
                         + flavour_of(cs.jets()[lookup[parent2]]);
      newjet.set_user_info(new FlavInfo(newflav));
      int k;
      //cout << i << " " << parent1 << " " << parent2 << " " << dij << endl;
      cs.plugin_record_ij_recombination(lookup[parent1], lookup[parent2], dij, 
                                        newjet, k);
      lookup[i] = k;
      beam_index = 0;
      //cout << "combining " << lookup[parent1] << " " << lookup[parent2] << " into " << k << " " << flavour_of(newjet).description() << endl;
    } else {
      cs.plugin_record_iB_recombination(lookup[parent2], dij);
      if        (parent1 == -2) {
        beam_flavour.backward = beam_flavour.backward - flavour_of(cs.jets()[lookup[parent2]]);
        beam_index = -1;
      } else if (parent1 == -1) {
        beam_flavour.forward  = beam_flavour.forward  - flavour_of(cs.jets()[lookup[parent2]]);
        beam_index = +1;
      } else {
        throw Error("inconsistent parent1 value");
      }
    }
    beam_flavour.label_as_beam(); // always do this to make sure we have correct labelling
    extras->_beam_flavs.push_back(beam_flavour);
    extras->_beam_indices.push_back(beam_index);
  }
  ktf77DeleteNodeList();
  extras->_bf_offset = int(extras->_beam_flavs.size()) - int(cs.history().size());
  auto_ptr<ClusterSequence::Extras> extras_auto_ptr(extras);
  cs.plugin_associate_extras(extras_auto_ptr);
}

//----------------------------------------------------------------------
/// return the index of _beam_flavs that corresponds to the beam
/// flavour at the stage where we have exactly n_exclusive_jets
int MyFlavKtPlugin::Extras::bf_index(int n_exclusive_jets) const {
  int index = 2*int(_cs.n_particles()) - 1 - n_exclusive_jets + _bf_offset;
  if (index < 0) index = 0;
  if (index >= int(_beam_flavs.size())) throw Error("beam flavours do not exist for the requested number of exclusive jets (maybe clustering stopped earlier?)");
  return index;
}

//----------------------------------------------------------------------
/// returns
/// - +1 if the specified jet clusters with the forward-going beam
/// - -1 if it clusters with the backward-going beam
/// -  0 if it clusters with another PseudoJet or does not cluster at all
int MyFlavKtPlugin::Extras::beam_it_clusters_with(const PseudoJet & jet) const {
  assert(jet.associated_cs() == &_cs); // make sure jets are right ones
  int child = _cs.history()[jet.cluster_hist_index()].child;
  if (child == ClusterSequence::Invalid) return 0;
  else {
    // if child index is outside this range, we have a problem
    assert (child >= 0 && child < int(_beam_indices.size()));
    return _beam_indices[child];
  }
    
}

FASTJET_END_NAMESPACE        // defined in fastjet/internal/base.hh
